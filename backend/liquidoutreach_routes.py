"""\nLiquidOutreach API Routes\nComplete REST API for persona-centric outreach orchestration\n"""\n\nfrom fastapi import APIRouter, HTTPException, Depends, BackgroundTasks\nfrom typing import List, Optional\nimport logging\nfrom datetime import datetime, timezone, timedelta\nimport uuid\n\nfrom liquidoutreach_models import (\n    CreatePersonaRequest, ImportProspectRequest, EnrollProspectRequest,\n    CreateCampaignRequest, AddCampaignStepRequest, CreateTemplateRequest,\n    ProspectControlRequest, PhantombusterWebhookPayload,\n    Persona, Prospect, Campaign, Template, ActivityLog\n)\nfrom orchestration_engine import OrchestrationEngine\n\nlogger = logging.getLogger(__name__)\n\n# Router\nliquidoutreach_router = APIRouter(prefix="/api/liquid", tags=["LiquidOutreach"])\n\n# Dependency injection\nengine: Optional[OrchestrationEngine] = None\n\ndef get_engine() -> OrchestrationEngine:\n    if engine is None:\n        raise HTTPException(status_code=500, detail="Engine not initialized")\n    return engine\n\n\n# ============ PERSONA MANAGEMENT ============\n\n@liquidoutreach_router.post("/personas")\nasync def create_persona(\n    request: CreatePersonaRequest,\n    user_id: str = "user-patriot-1762275399425",  # TODO: Get from auth\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Create a new sales persona\"\"\"\n    try:\n        persona_id = str(uuid.uuid4())\n        persona = {\n            \"id\": persona_id,\n            \"name\": request.name,\n            \"credentials\": {\n                \"email\": request.email,\n                \"sendgrid_api_key\": request.sendgrid_api_key,\n                \"phantombuster_api_key\": request.phantombuster_api_key,\n                \"phantom_connect_id\": request.phantom_connect_id,\n                \"phantom_message_id\": request.phantom_message_id,\n                \"phantom_view_id\": request.phantom_view_id\n            },\n            \"assigned_user_id\": request.assigned_user_id or user_id,\n            \"is_active\": True,\n            \"created_at\": datetime.now(timezone.utc).isoformat(),\n            \"updated_at\": datetime.now(timezone.utc).isoformat()\n        }\n        \n        await orchestrator.db.personas.insert_one(persona)\n        \n        return {\"id\": persona_id, \"name\": request.name, \"message\": \"Persona created\"}\n    except Exception as e:\n        logger.error(f\"Create persona error: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@liquidoutreach_router.get(\"/personas\")\nasync def list_personas(\n    user_id: str = \"user-patriot-1762275399425\",\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"List all personas for user\"\"\"\n    personas = await orchestrator.db.personas.find({\n        \"assigned_user_id\": user_id\n    }, {\"_id\": 0}).to_list(100)\n    return personas\n\n\n@liquidoutreach_router.get(\"/personas/{persona_id}\")\nasync def get_persona(\n    persona_id: str,\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Get persona details\"\"\"\n    persona = await orchestrator.db.personas.find_one({\"id\": persona_id}, {\"_id\": 0})\n    if not persona:\n        raise HTTPException(status_code=404, detail=\"Persona not found\")\n    return persona\n\n\n# ============ PROSPECT MANAGEMENT ============\n\n@liquidoutreach_router.post(\"/prospects/import\")\nasync def import_prospect(\n    request: ImportProspectRequest,\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Import a prospect with duplicate checking\"\"\"\n    \n    # Check for duplicates\n    existing = await orchestrator.db.prospects.find_one({\n        \"$or\": [\n            {\"email\": request.email},\n            {\"linkedin_url\": request.linkedin_url} if request.linkedin_url else {}\n        ]\n    })\n    \n    if existing:\n        return {\n            \"duplicate\": True,\n            \"existing_prospect_id\": existing[\"id\"],\n            \"locked_to_persona_id\": existing.get(\"assigned_persona_id\"),\n            \"message\": \"Prospect already exists and is locked to another persona\"\n        }\n    \n    # Create new prospect\n    prospect_id = str(uuid.uuid4())\n    prospect = {\n        \"id\": prospect_id,\n        \"first_name\": request.first_name,\n        \"last_name\": request.last_name,\n        \"email\": request.email,\n        \"linkedin_url\": request.linkedin_url,\n        \"company\": request.company,\n        \"title\": request.title,\n        \"status\": \"NEW\",\n        \"assigned_persona_id\": None,\n        \"locked_at\": None,\n        \"current_campaign_id\": None,\n        \"current_step_id\": None,\n        \"next_step_due_at\": None,\n        \"created_at\": datetime.now(timezone.utc).isoformat(),\n        \"updated_at\": datetime.now(timezone.utc).isoformat()\n    }\n    \n    await orchestrator.db.prospects.insert_one(prospect)\n    \n    return {\n        \"duplicate\": False,\n        \"prospect_id\": prospect_id,\n        \"message\": \"Prospect imported successfully\"\n    }\n\n\n@liquidoutreach_router.get(\"/prospects\")\nasync def list_prospects(\n    status: Optional[str] = None,\n    persona_id: Optional[str] = None,\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"List prospects with optional filters\"\"\"\n    query = {}\n    if status:\n        query[\"status\"] = status\n    if persona_id:\n        query[\"assigned_persona_id\"] = persona_id\n    \n    prospects = await orchestrator.db.prospects.find(query, {\"_id\": 0}).to_list(1000)\n    return prospects\n\n\n@liquidoutreach_router.get(\"/prospects/{prospect_id}/timeline\")\nasync def get_prospect_timeline(\n    prospect_id: str,\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Get unified activity timeline for a prospect\"\"\"\n    activities = await orchestrator.db.activity_log.find(\n        {\"prospect_id\": prospect_id},\n        {\"_id\": 0}\n    ).sort(\"timestamp\", -1).to_list(1000)\n    \n    return activities\n\n\n# ============ ENROLLMENT & CONTROL ============\n\n@liquidoutreach_router.post(\"/prospects/enroll\")\nasync def enroll_prospect(\n    request: EnrollProspectRequest,\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Enroll prospect in a sequence with a persona (LOCKS them)\"\"\"\n    \n    # Get prospect\n    prospect = await orchestrator.db.prospects.find_one({\"id\": request.prospect_id})\n    if not prospect:\n        raise HTTPException(status_code=404, detail=\"Prospect not found\")\n    \n    # Check if already locked\n    if prospect.get(\"assigned_persona_id\") and prospect[\"assigned_persona_id\"] != request.persona_id:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Prospect is locked to persona {prospect['assigned_persona_id']}\"\n        )\n    \n    # Get campaign and first step\n    campaign = await orchestrator.db.campaigns.find_one({\"id\": request.campaign_id})\n    if not campaign or campaign[\"status\"] != \"ACTIVE\":\n        raise HTTPException(status_code=400, detail=\"Campaign not active\")\n    \n    first_step = await orchestrator.db.campaign_steps.find_one({\n        \"campaign_id\": request.campaign_id,\n        \"step_number\": 1\n    })\n    \n    if not first_step:\n        raise HTTPException(status_code=400, detail=\"Campaign has no steps\")\n    \n    # Enroll and LOCK\n    now = datetime.now(timezone.utc)\n    next_due = now + timedelta(days=first_step[\"delay_in_days\"])\n    \n    await orchestrator.db.prospects.update_one(\n        {\"id\": request.prospect_id},\n        {\n            \"$set\": {\n                \"status\": \"ACTIVE\",\n                \"assigned_persona_id\": request.persona_id,  # LOCK\n                \"locked_at\": now.isoformat(),\n                \"current_campaign_id\": request.campaign_id,\n                \"current_step_id\": first_step[\"id\"],\n                \"next_step_due_at\": next_due.isoformat(),\n                \"updated_at\": now.isoformat()\n            }\n        }\n    )\n    \n    # Log enrollment\n    await orchestrator._log_activity(\n        prospect_id=request.prospect_id,\n        persona_id=request.persona_id,\n        campaign_id=request.campaign_id,\n        step_id=None,\n        channel=\"MANUAL_NOTE\",\n        action=\"Enrolled in Sequence\",\n        status=\"COMPLETED\",\n        details=f\"Enrolled in {campaign['name']}\"\n    )\n    \n    return {\n        \"message\": \"Prospect enrolled and locked to persona\",\n        \"next_step_due_at\": next_due.isoformat()\n    }\n\n\n@liquidoutreach_router.post(\"/prospects/control\")\nasync def control_prospect(\n    request: ProspectControlRequest,\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Manually control prospect status (pause/unpause/retry)\"\"\"\n    \n    prospect = await orchestrator.db.prospects.find_one({\"id\": request.prospect_id})\n    if not prospect:\n        raise HTTPException(status_code=404, detail=\"Prospect not found\")\n    \n    if request.action == \"PAUSE\":\n        await orchestrator.db.prospects.update_one(\n            {\"id\": request.prospect_id},\n            {\"$set\": {\"status\": \"PAUSED_MANUAL_REVIEW\"}}\n        )\n        return {\"message\": \"Prospect paused\"}\n    \n    elif request.action == \"UNPAUSE\":\n        await orchestrator.db.prospects.update_one(\n            {\"id\": request.prospect_id},\n            {\"$set\": {\"status\": \"ACTIVE\"}}\n        )\n        return {\"message\": \"Prospect unpaused\"}\n    \n    elif request.action == \"RETRY_STEP\":\n        # Reset next_step_due_at to now\n        await orchestrator.db.prospects.update_one(\n            {\"id\": request.prospect_id},\n            {\n                \"$set\": {\n                    \"status\": \"ACTIVE\",\n                    \"next_step_due_at\": datetime.now(timezone.utc).isoformat()\n                }\n            }\n        )\n        return {\"message\": \"Step will retry on next scheduler run\"}\n\n\n# ============ CAMPAIGN MANAGEMENT ============\n\n@liquidoutreach_router.post(\"/campaigns\")\nasync def create_campaign(\n    request: CreateCampaignRequest,\n    user_id: str = \"user-patriot-1762275399425\",\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Create a new campaign (sequence)\"\"\"\n    campaign_id = str(uuid.uuid4())\n    campaign = {\n        \"id\": campaign_id,\n        \"name\": request.name,\n        \"status\": \"DRAFT\",\n        \"created_by_user_id\": user_id,\n        \"created_at\": datetime.now(timezone.utc).isoformat(),\n        \"updated_at\": datetime.now(timezone.utc).isoformat()\n    }\n    \n    await orchestrator.db.campaigns.insert_one(campaign)\n    return {\"id\": campaign_id, \"name\": request.name}\n\n\n@liquidoutreach_router.get(\"/campaigns\")\nasync def list_campaigns(\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"List all campaigns\"\"\"\n    campaigns = await orchestrator.db.campaigns.find({}, {\"_id\": 0}).to_list(100)\n    return campaigns\n\n\n@liquidoutreach_router.post(\"/campaigns/{campaign_id}/activate\")\nasync def activate_campaign(\n    campaign_id: str,\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Activate a campaign\"\"\"\n    result = await orchestrator.db.campaigns.update_one(\n        {\"id\": campaign_id},\n        {\"$set\": {\"status\": \"ACTIVE\"}}\n    )\n    \n    if result.modified_count == 0:\n        raise HTTPException(status_code=404, detail=\"Campaign not found\")\n    \n    return {\"message\": \"Campaign activated\"}\n\n\n@liquidoutreach_router.post(\"/campaigns/steps\")\nasync def add_campaign_step(\n    request: AddCampaignStepRequest,\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Add a step to a campaign\"\"\"\n    \n    # Get current max step number\n    existing_steps = await orchestrator.db.campaign_steps.find(\n        {\"campaign_id\": request.campaign_id}\n    ).sort(\"step_number\", -1).to_list(1)\n    \n    next_step_number = 1\n    if existing_steps:\n        next_step_number = existing_steps[0][\"step_number\"] + 1\n    \n    step_id = str(uuid.uuid4())\n    step = {\n        \"id\": step_id,\n        \"campaign_id\": request.campaign_id,\n        \"step_number\": next_step_number,\n        \"channel\": request.channel,\n        \"action\": request.action,\n        \"template_id\": request.template_id,\n        \"delay_in_days\": request.delay_in_days,\n        \"created_at\": datetime.now(timezone.utc).isoformat(),\n        \"updated_at\": datetime.now(timezone.utc).isoformat()\n    }\n    \n    await orchestrator.db.campaign_steps.insert_one(step)\n    \n    return {\"id\": step_id, \"step_number\": next_step_number}\n\n\n# ============ TEMPLATES ============\n\n@liquidoutreach_router.post(\"/templates\")\nasync def create_template(\n    request: CreateTemplateRequest,\n    user_id: str = \"user-patriot-1762275399425\",\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Create a message template\"\"\"\n    template_id = str(uuid.uuid4())\n    template = {\n        \"id\": template_id,\n        \"name\": request.name,\n        \"channel\": request.channel,\n        \"action_type\": request.action_type,\n        \"email_subject\": request.email_subject,\n        \"body_text\": request.body_text,\n        \"created_by_user_id\": user_id,\n        \"created_at\": datetime.now(timezone.utc).isoformat(),\n        \"updated_at\": datetime.now(timezone.utc).isoformat()\n    }\n    \n    await orchestrator.db.templates.insert_one(template)\n    \n    return {\"id\": template_id, \"name\": request.name}\n\n\n@liquidoutreach_router.get(\"/templates\")\nasync def list_templates(\n    channel: Optional[str] = None,\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"List all templates\"\"\"\n    query = {}\n    if channel:\n        query[\"channel\"] = channel\n    \n    templates = await orchestrator.db.templates.find(query, {\"_id\": 0}).to_list(100)\n    return templates\n\n\n# ============ WEBHOOKS ============\n\n@liquidoutreach_router.post(\"/webhooks/phantombuster/{prospect_id}\")\nasync def phantombuster_webhook(\n    prospect_id: str,\n    payload: PhantombusterWebhookPayload,\n    background_tasks: BackgroundTasks,\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Receive webhook from Phantombuster\"\"\"\n    \n    logger.info(f\"Received Phantombuster webhook for prospect {prospect_id}\")\n    \n    # Handle asynchronously\n    background_tasks.add_task(\n        orchestrator.handle_phantombuster_webhook,\n        prospect_id=prospect_id,\n        container_id=payload.containerId,\n        status=payload.status,\n        error=payload.error\n    )\n    \n    return {\"message\": \"Webhook received\"}\n\n\n@liquidoutreach_router.post(\"/webhooks/email-reply\")\nasync def email_reply_webhook(\n    prospect_email: str,\n    background_tasks: BackgroundTasks,\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Handle email reply detection\"\"\"\n    \n    logger.info(f\"Email reply detected from {prospect_email}\")\n    \n    background_tasks.add_task(\n        orchestrator.handle_email_reply,\n        prospect_email=prospect_email\n    )\n    \n    return {\"message\": \"Reply processed\"}\n\n\n# ============ ACTION CENTER ============\n\n@liquidoutreach_router.get(\"/action-center/action-required\")\nasync def get_action_required(\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Get prospects requiring manual attention\"\"\"\n    \n    # Replied prospects\n    replied = await orchestrator.db.prospects.find(\n        {\"status\": \"REPLIED\"},\n        {\"_id\": 0}\n    ).to_list(100)\n    \n    # Failed steps\n    failed = await orchestrator.db.prospects.find(\n        {\"status\": \"PAUSED_MANUAL_REVIEW\"},\n        {\"_id\": 0}\n    ).to_list(100)\n    \n    return {\n        \"replied\": replied,\n        \"failed_steps\": failed,\n        \"total_action_required\": len(replied) + len(failed)\n    }\n\n\n# ============ SCHEDULER TRIGGER ============\n\n@liquidoutreach_router.post(\"/scheduler/run\")\nasync def trigger_scheduler(\n    background_tasks: BackgroundTasks,\n    orchestrator: OrchestrationEngine = Depends(get_engine)\n):\n    \"\"\"Manually trigger the scheduler (also runs via cron)\"\"\"\n    \n    background_tasks.add_task(orchestrator.run_scheduler)\n    \n    return {\"message\": \"Scheduler triggered\"}\n"